/** Declaration file generated by dts-gen */

declare module 'timeseries-analysis' {

	export type Data = Array<Array<number>>

	export interface Options {
		data?: Data
		period?: number
		alpha?: number
		use?: string
		grid?: number
		threshold?: number
		forecast?: number
		forecast_length?: number
		method?: string
		sample?: number
		start?: number
		n?: number
		degree?: number
		maxPct?: number
		maxSampleSize?: number
		intermediates?: boolean
		cycles?: number
		quality?: number
		inertia?: number
	}

	export interface AnalysisResults {
		autocorrelation: number
		durbinWatson: number
		runs: number
		trend: number
	}

	export interface OptimizeResults {
		sample: number
		degree: number
		method: string
		MSE: number
	}

	export class main {

		buffer: Data

		data: Data

		original: Data

		saved: Data

		options: Options

		constructor(data: Data, options?: Options)

		ARLeastSquare(options?: Options): Array<number>

		ARMaxEntropy(options?: Options): Array<number>

		SolveLE(mat: any, vec: any, n: any): any

		chart(options: Options): any

		clone(): any

		cycle(options?: Options): this

		dsp_itrend(options?: Options): this

		// durbinWatson(): any

		ema(options: Options): this

		fill(value: any, n: any): any

		lwma(options: Options): this

		ma(options: Options): this

		max(): number

		mean(data: Data): number

		min(): number

		noiseData(): any

		offset(value: any, data: Data, ret: any): any

		osc(): this

		outliers(options?: Options): Data

		output(): Data

		pixelize(options?: Options): this

		regression_analysis(options?: Options): AnalysisResults

		regression_forecast(options?: Options): this

		regression_forecast_mse(options?: Options): any

		regression_forecast_optimize(options?: Options): OptimizeResults

		reset(): void

		save(name: any, options: Options): any

		slice(from: any, to: any): any

		sliding_regression_forecast(options: Options): any

		smoother(options: Options): this

		standardize(options?: Options): this

		stdev(data: Data): any

		supports(options?: Options): Array<string>

		toArray(): any

	}

	export namespace adapter {

		function complex(options: Options): any

		function fromArray(data: Data): any

		function fromDB(data: Data, options: Options): any

		function geometric(options: Options): any

		function sin(options: Options): any

		function tan(options: Options): any

	}

	export const version: string

}

